import math
import string
import os
import random
la = string.ascii_lowercase
ua = string.ascii_uppercase
script_path = os.path.abspath(__file__)
project_dir = script_path[:script_path.rfind("algs")]
input_path = project_dir + "inputs/"

import sys
sys.path.append(project_dir)
from student_utils import *

def random_name(n):
	"""
	n is number of name
	"""
	name_set = set(["Soda"])

	while True:
		rand_name_len = random.randint(3, 10) # 3 <= len <= 10
		name = ua[random.randint(0, 25)]
		for _ in range(rand_name_len):
			name  = name + la[random.randint(0, 25)]
		name_set.add(name)
		if len(name_set) == n:
			break
	name_list = list(name_set)
	return name_list

def random_home(name_list, home_num):
	home_idx_set = set()
	home_list = []
	while True:
		idx = random.randint(0, len(name_list)-1)
		if idx not in home_idx_set:
			home_idx_set.add(idx)
			home_list.append(name_list[idx])

		if len(home_list) == home_num:
			break
	return home_list

def remove_random_edges(G, ratio=0.3):
	'''
	ratio of #edges/#fully_connected_edges
	'''
	num_edges = len(G.edges)
	num_edges_removed = math.floor(num_edges * (1-ratio))
	removed_edge = set()
	while True:
		removed_edge.add(random.randrange(0, num_edges-1))
		if len(removed_edge) == num_edges_removed:
			break

	for idx,(u,v) in enumerate(list(G.edges)):
		if idx in removed_edge:
			G.remove_edge(u,v)


L2_dis = lambda pos1, pos2 : ((pos1[0]-pos2[0])**2 + (pos1[1]-pos2[1])**2)**0.5
def adjacent_matrix(m,n):
	G = nx.random_geometric_graph(m, 1000)
	# we use the default pos generated by this method, but we
	# do have the freedom to custom our own nodes
	# and we can remove and add nodes and edges after this as we will

	remove_random_edges(G, 0.1)
	show(G)
	node_num = len(G)
	# for u,v in G.edges:
	# 	dis = L2_dis(G.nodes[u]['pos'],G.nodes[v]['pos'])
	# 	print(dis)

	# calculate weights
	for u,v in list(G.edges):
		round_pos_u = [round(G.nodes[u]['pos'][0]*100, 0), round(G.nodes[u]['pos'][1]*100, 0)]
		round_pos_v = [round(G.nodes[v]['pos'][0]*100, 0), round(G.nodes[v]['pos'][1]*100, 0)]
		dis = L2_dis(round_pos_u, round_pos_v)
		G.edges[u,v]['weight'] = round(dis+0.0001, 4)
	return graph_to_matrix(G)


def random_input(m, n):
	"""
	m the number of locations, n the number of TA's home
	"""
	in_str = str(m) + '\n' + str(n) + '\n'
	locations = random_name(m)
	for loc in locations:
		in_str = in_str + str(loc) + ' '
	in_str = in_str + '\n'
	homes = random_home(locations, n)
	for home in homes:
		in_str = in_str + str(home) + ' '
	in_str = in_str + '\n' + 'Soda' + '\n'
	in_str = in_str + adjacent_matrix(m,n)
	return in_str


def save_file(m, n):
	in_str = random_input(m, n)
	with open(input_path + "%s.in"%m, 'w+') as f:
		f.write(in_str)



if __name__ == '__main__':
	# random_metric_graph(10)
	# name_set = random_name(10)
	# print(name_set)

	# nlist = random_home(name_set, 3)
	# print(nlist)

	# print(random_input(10, 3))

	save_file(50, 25)
	save_file(100, 50)
	save_file(200, 100)


